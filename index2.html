<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Distributed Donut</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      min-height: 100vh;
      background: linear-gradient(to bottom, #fff0f5, #e6e6fa);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      padding: 2rem;
    }

    .container {
      width: 100%;
      max-width: 64rem;
    }

    h1 {
      font-size: 2.25rem;
      font-weight: bold;
      text-align: center;
      color: #6b46c1;
    }

    .subtitle {
      font-size: 1.25rem;
      text-align: center;
      color: #805ad5;
      margin-top: 0.5rem;
    }

    main {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .donut-card {
      background-color: white;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      padding: 2rem;
      margin-bottom: 2rem;
      text-align: center;
    }

    .donut-container {
      border: 4px dashed #d6bcfa;
      border-radius: 0.5rem;
      height: 32rem;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #a0aec0;
      overflow: hidden;
    }

    #donut {
      font-family: monospace;
      white-space: pre;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(1, 1fr);
      gap: 2rem;
      width: 100%;
    }

    @media (min-width: 768px) {
      .grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    .card {
      background-color: white;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .icon {
      height: 3rem;
      width: 3rem;
      color: #805ad5;
      margin-bottom: 1rem;
    }

    h2 {
      font-size: 1.25rem;
      font-weight: 600;
      color: #6b46c1;
      margin-bottom: 0.5rem;
    }

    .card p {
      color: #4a5568;
      text-align: center;
    }

    footer {
      margin-top: 3rem;
      text-align: center;
      color: #6b46c1;
    }
  </style>
</head>

<body>
  <script type="text/javascript">
    window.onload = function () {
      const donut = document.getElementById('donut');

      // Credit to VB-17 for the origin of the following JS implementation of the spinnning donut: https://github.com/GarvitSinghh/Donuts/blame/main/Donuts/donut.js
      const asciiframe = function (frameNumber) {
        const A = 1 + (0.07 * frameNumber);
        const B = 1 + (0.03 * frameNumber);

        const b = [];
        const z = [];

        const cA = Math.cos(A), sA = Math.sin(A),
          cB = Math.cos(B), sB = Math.sin(B);

        for (let k = 0; k < 1760; k++) {
          b[k] = k % 80 === 79 ? "\n" : " ";
          z[k] = 0;
        }

        for (let j = 0; j < 6.28; j += 0.07) {
          const ct = Math.cos(j), st = Math.sin(j);
          for (let i = 0; i < 6.28; i += 0.02) {
            const sp = Math.sin(i), cp = Math.cos(i),
              h = ct + 2,
              D = 1 / (sp * h * sA + st * cA + 5),
              t = sp * h * cA - st * sA;

            const x = 0 | (40 + 30 * D * (cp * h * cB - t * sB)),
              y = 0 | (12 + 15 * D * (cp * h * sB + t * cB)),
              o = x + 80 * y,
              N = 0 | (8 * ((st * sA - sp * ct * cA) * cB - sp * ct * sA - st * cA - cp * ct * sB));

            if (y < 22 && y >= 0 && x >= 0 && x < 79 && D > z[o]) {
              z[o] = D;
              b[o] = ".,-~:;=!*#$@"[N > 0 ? N : 0];
            }
          }
        }
        return b.join("");
      };

      class CircularBuffer {
        constructor(bufferLength) {
          this.buffer = new Array(bufferLength);
          this.head = 0;
          this.size = 0;
          this.bufferLength = bufferLength;
        }

        push(item) {
          if (this.size === this.bufferLength) {
            // Buffer is full, overwrite the oldest item
            this.head = (this.head + 1) % this.bufferLength;
          } else {
            this.size++;
          }

          const insertIndex = (this.head + this.size - 1) % this.bufferLength;
          this.buffer[insertIndex] = item;
        }

        get(index) {
          if (index < 0 || index >= this.size) {
            return null;
          }
          const actualIndex = (this.head + index) % this.bufferLength;
          return this.buffer[actualIndex];
        }

      }

      function createFrames(startFrame, endFrame) {
        const frames = new Array(endFrame - startFrame + 1);

        for (let i = startFrame; i < endFrame; i++) {
          frames[i - startFrame] = asciiframe(i);
        }
        return frames;
      }

      function drawFramesToCanvas() {
        let i = 0
        setInterval(() => {
          donut.innerHTML = frameBuffer.get(i);
          i = Math.floor((i + 1) % frameBuffer.size);

        }, 59);
      }

      const possibleCharacters = ".,-~:;=!*#$@ \n";

      // Encoding frames
      function encodeFrames(frames) {
        return frames.flatMap(frame => {
          const bytes = [];
          for (let i = 0; i < frame.length; i += 2) {
            const char1 = frame[i];
            const char2 = i + 1 < frame.length ? frame[i + 1] : 12; // possibleCharacters[12]=space ; Used here if there's no second character

            const index1 = possibleCharacters.indexOf(char1);
            const index2 = possibleCharacters.indexOf(char2);

            if (index1 === -1 || index2 === -1) {
              throw new Error(`Invalid character found: ${char1} or ${char2}`);
            }
            // console.log("index1: " + index1 + " index2: " + index2);


            const byte = (index1 << 4) | index2;
            bytes.push(byte);
          }
          return bytes;
        });
      }

      const FrameSize = 880; // bytes
      const WorkSize = FrameSize; // Adjusted to match server-side WorkSize for a single frame
      const FramesPerChunk = 363; // Calculated from the received data size

      // Decoding frames
      function decodeFrames(encodedFrames) {
        const decodedFrames = [];
        const frameCount = Math.floor(encodedFrames.length / WorkSize);

        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
          let currentFrame = "";
          const frameStart = frameIndex * WorkSize;
          const frameEnd = frameStart + WorkSize;

          for (let i = frameStart; i < frameEnd; i++) {
            const byte = encodedFrames[i];
            const char = possibleCharacters[byte % possibleCharacters.length];
            currentFrame += char;
          }

          if (currentFrame.length === 1760) {
            decodedFrames.push(currentFrame);
          } else {
            console.warn(`Incomplete frame ${frameIndex}: length ${currentFrame.length}`);
          }
        }

        return decodedFrames;
      }




      // Test function to verify encoding/decoding
      function testEncodingDecoding() {
        const testFrame = ".,-~:;=!*#$@ \n".repeat(136).slice(0, 1760); // 1760 characters
        console.log("Test frame length:", testFrame.length);

        // Simulate server-side encoding
        const encodedFrame = new Uint8Array(FrameSize);
        for (let i = 0; i < testFrame.length; i += 2) {
          const char1Index = possibleCharacters.indexOf(testFrame[i]);
          const char2Index = possibleCharacters.indexOf(testFrame[i + 1]);
          encodedFrame[i / 2] = (char1Index << 4) | char2Index;
        }

        console.log("Encoded frame length:", encodedFrame.length);
        console.log("First few encoded bytes:", Array.from(encodedFrame.slice(0, 10)).map(b => b.toString(16).padStart(2, '0')).join(' '));

        // Decode the frame
        const decodedFrames = decodeFrames(encodedFrame);
        console.log("Decoded frame count:", decodedFrames.length);
        console.log("Decoded frame length:", decodedFrames[0].length);
        console.log("Original and decoded match:", testFrame === decodedFrames[0]);

        if (testFrame !== decodedFrames[0]) {
          console.log("First 50 characters of original:", testFrame.slice(0, 50));
          console.log("First 50 characters of decoded:", decodedFrames[0].slice(0, 50));
        }
      }

      function testReceivedDataDecoding() {
        // Simulating the first few bytes of received data
        const testData = new Uint8Array([0x30, 0x34, 0x2c, 0x32, 0x30, 0x34, 0x2c, 0x32, 0x30, 0x34, 0x2c, 0x32, 0x30, 0x34, 0x2c, 0x32, 0x30, 0x34, 0x2c, 0x32]);

        console.log("Test data:", Array.from(testData).map(b => b.toString(16).padStart(2, '0')).join(' '));

        // Convert ASCII values to characters
        const decodedChars = Array.from(testData).map(asciiToChar).join('');
        console.log("Decoded characters:", decodedChars);

        // Apply our decoding function
        const decodedFrames = decodeFrames(testData);
        console.log("Decoded frame (first 50 chars):", decodedFrames[0]?.slice(0, 50));
      }


      function asciiToChar(ascii) {
        return String.fromCharCode(ascii);
      }


      const ws = new WebSocket("ws://localhost:8080/connect");
      ws.binaryType = 'arraybuffer';
      ws.onopen = function () {
        console.log("Connection established");
      };
      const frameBuffer = new CircularBuffer(12 * 60); // 12 seconds of animation


      ws.onmessage = function (e) {
        const data = e.data;
        const dv = new DataView(data);
        const messageType = dv.getUint8(0);


        if (messageType === 0x0) { // Received work request message

          console.log("Received work request");

          const startFrame = dv.getUint32(1);
          const endFrame = dv.getUint32(5);

          console.log("Server requested work from " + startFrame + " to " + endFrame);
          const work = createFrames(startFrame, endFrame);
          const encodedData = encodeFrames(work);
          // console.log("111-> Encoded work: " + encodedData);

          // const decodedFrames = decodeFrames(encodedData);
          // console.log("Decoded frames: " + decodedFrames);

          console.log("Work done, sending to server...");
          ws.send(encodedData);
        } else if (messageType === 0x2) { // MessageTypeFrameBroadcast
          console.log("Received frame chunk broadcast. Drawing to canvas...");

          // Create a Uint8Array from the ArrayBuffer, excluding the first byte
          const encodedData = new Uint8Array(data, 1);

          console.log("Encoded data length:", encodedData.length);
          console.log("First few bytes:", Array.from(encodedData.slice(0, 20)).map(b => b.toString(16).padStart(2, '0')).join(' '));

          const decodedFrames = decodeFrames(encodedData);
          console.log("Decoded frames count:", decodedFrames.length);
          console.log("First decoded frame length:", decodedFrames[0]?.length);
          console.log("First 50 characters of first decoded frame:", decodedFrames[0]?.slice(0, 50));

          // Add the decoded frames to the circular buffer
          decodedFrames.forEach(frame => frameBuffer.push(frame));



          // Start drawing the frames to the canvas
          // drawFramesToCanvas()
          testReceivedDataDecoding();
        } else {
          console.log("Received other message type:", messageType);
        }
      };

      ws.onclose = function () {
        console.log("Connection closed");
      };

    }
  </script>
  <header class="container">
    <h1>Distributed Donut</h1>
    <p class="subtitle">A deliciously collaborative ASCII art project</p>
  </header>
  <main class="container">
    <div class="donut-card">
      <p style="font-size: 1.125rem; color: #4a5568; margin-bottom: 1rem;">
        Watch as browsers around the world come together to create a mesmerizing spinning donut!
      </p>
      <div class="donut-container">
        <pre id="donut"></pre>
      </div>
    </div>
    <div class="grid">
      <div class="card">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
          stroke-linejoin="round">
          <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
          <circle cx="9" cy="7" r="4"></circle>
          <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
          <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
        </svg>
        <h2>Collaborative</h2>
        <p>Each browser contributes to the animation</p>
      </div>
      <div class="card">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
          stroke-linejoin="round">
          <circle cx="12" cy="12" r="10"></circle>
          <line x1="12" y1="16" x2="12" y2="12"></line>
          <line x1="12" y1="8" x2="12.01" y2="8"></line>
        </svg>
        <h2>How It Works</h2>
        <p>Distributed rendering of ASCII frames</p>
      </div>
      <div class="card">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
          stroke-linejoin="round">
          <path
            d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
          </path>
        </svg>
        <h2>Open Source</h2>
        <p>Check out the code on GitHub</p>
      </div>
    </div>
  </main>
  <footer class="container">
    <p>Made by <a href="https://github.com/Issaminu" target="_blank">Issam Boubcher</a>.</p>
  </footer>
</body>

</html>